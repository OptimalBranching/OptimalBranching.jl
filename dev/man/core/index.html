<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OptimalBranchingCore · OptimalBranching.jl</title><meta name="title" content="OptimalBranchingCore · OptimalBranching.jl"/><meta property="og:title" content="OptimalBranchingCore · OptimalBranching.jl"/><meta property="twitter:title" content="OptimalBranchingCore · OptimalBranching.jl"/><meta name="description" content="Documentation for OptimalBranching.jl."/><meta property="og:description" content="Documentation for OptimalBranching.jl."/><meta property="twitter:description" content="Documentation for OptimalBranching.jl."/><meta property="og:url" content="https://OptimalBranching.github.io/OptimalBranching.jl/man/core/"/><meta property="twitter:url" content="https://OptimalBranching.github.io/OptimalBranching.jl/man/core/"/><link rel="canonical" href="https://OptimalBranching.github.io/OptimalBranching.jl/man/core/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OptimalBranching.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick-start/">Quick Start</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/rule_discovery/">Automatic rule discovery</a></li></ul></li><li><a class="tocitem" href="../../benchmarks/">Benchmarks</a></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>OptimalBranchingCore</a><ul class="internal"><li><a class="tocitem" href="#Literal,-Clause-and-DNF"><span>Literal, Clause and DNF</span></a></li><li><a class="tocitem" href="#The-branch-and-bound-algorithm"><span>The branch and bound algorithm</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../mis/">OptimalBranchingMIS</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>OptimalBranchingCore</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OptimalBranchingCore</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OptimalBranching/OptimalBranching.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/main/docs/src/man/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="core"><a class="docs-heading-anchor" href="#core">OptimalBranchingCore</a><a id="core-1"></a><a class="docs-heading-anchor-permalink" href="#core" title="Permalink"></a></h1><h2 id="Literal,-Clause-and-DNF"><a class="docs-heading-anchor" href="#Literal,-Clause-and-DNF">Literal, Clause and DNF</a><a id="Literal,-Clause-and-DNF-1"></a><a class="docs-heading-anchor-permalink" href="#Literal,-Clause-and-DNF" title="Permalink"></a></h2><p>Literals, clauses and disjunctive normal form (DNF) are basic concepts in boolean logic, where literals are boolean variables, clauses are boolean expressions, and DNF is a disjunction of one or more conjunctions of literals.</p><p>Here is an example, given a truth table as follows:</p><table><tr><th style="text-align: center">a</th><th style="text-align: center">b</th><th style="text-align: center">c</th><th style="text-align: center">value</th></tr><tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td></tr><tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr><tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr></table><p>where <span>$a, b, c$</span> are boolean variables called literals. The true statements can be represented as a conjunction of literals, for example, </p><p class="math-container">\[\neg a \land \neg b \land \neg c, \neg a \land \neg b \land c, a \land \neg b \land c\]</p><p>and these clauses can be combined into a DNF:</p><p class="math-container">\[(\neg a \land \neg b) \lor (a \land \neg b \land c).\]</p><p>In <code>OptimalBranchingCore</code>, a clause is represented by the <a href="#OptimalBranchingCore.Clause"><code>Clause</code></a> type, and a DNF is represented by the <a href="#OptimalBranchingCore.DNF"><code>DNF</code></a> type, based on the <code>BitBasis.jl</code> package.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using OptimalBranchingCore, BitBasis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c1 = Clause(bit&quot;011&quot;, bit&quot;000&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Clause{BitBasis.DitStr{2, 3, Int64}}: ¬#1 ∧ ¬#2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c2 = Clause(bit&quot;111&quot;, bit&quot;101&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Clause{BitBasis.DitStr{2, 3, Int64}}: #1 ∧ ¬#2 ∧ #3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dnf = DNF(c1, c2)</code><code class="nohighlight hljs ansi" style="display:block;">DNF{BitBasis.DitStr{2, 3, Int64}}: (¬#1 ∧ ¬#2) ∨ (#1 ∧ ¬#2 ∧ #3)</code></pre><h2 id="The-branch-and-bound-algorithm"><a class="docs-heading-anchor" href="#The-branch-and-bound-algorithm">The branch and bound algorithm</a><a id="The-branch-and-bound-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-branch-and-bound-algorithm" title="Permalink"></a></h2><p>The branch and bound algorithm is a method to exactly solve the combinatorial optimization problems.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.apply_branch" href="#OptimalBranchingCore.apply_branch"><code>OptimalBranchingCore.apply_branch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_branch(problem::AbstractProblem, clause::Clause, vertices::Vector)::Tuple</code></pre><p>Create a branch from the given clause applied to the specified vertices.</p><p><strong>Arguments</strong></p><ul><li><code>problem</code>: The problem instance.</li><li><code>clause</code>: The clause that containing the information about how to fix the values of the variables.</li><li><code>vertices</code>: A vector of vertices to be considered for the branch.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractProblem</code>: A new instance of <code>AbstractProblem</code> with reduced size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.branch_and_reduce-Tuple{AbstractProblem, BranchingStrategy, AbstractReducer, Any}" href="#OptimalBranchingCore.branch_and_reduce-Tuple{AbstractProblem, BranchingStrategy, AbstractReducer, Any}"><code>OptimalBranchingCore.branch_and_reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branch_and_reduce(problem::AbstractProblem, config::BranchingStrategy; reducer::AbstractReducer=NoReducer(), result_type=Int, show_progress=false)</code></pre><p>Branch the given problem using the specified solver configuration.</p><p><strong>Arguments</strong></p><ul><li><code>problem</code>: The problem instance to solve.</li><li><code>config</code>: The configuration for the solver, which is a <a href="#OptimalBranchingCore.BranchingStrategy"><code>BranchingStrategy</code></a> instance.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>reducer::AbstractReducer=NoReducer()</code>: The reducer to reduce the problem size.</li><li><code>result_type::Type{TR}</code>: The type of the result that the solver will produce.</li></ul><p><strong>Returns</strong></p><p>The resulting value, which may have different type depending on the <code>result_type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/branch.jl#L54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.branching_table" href="#OptimalBranchingCore.branching_table"><code>OptimalBranchingCore.branching_table</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">branching_table(problem::AbstractProblem, table_solver::AbstractTableSolver, variables::Vector{Int})</code></pre><p>Obtains the branching table for a given problem using a specified table solver.</p><p><strong>Arguments</strong></p><ul><li><code>problem</code>: The problem instance.</li><li><code>table_solver</code>: The table solver, which is a subtype of <a href="#OptimalBranchingCore.AbstractTableSolver"><code>AbstractTableSolver</code></a>.</li><li><code>variables</code>: A vector of indices of the variables to be considered for the branching table.</li></ul><p><strong>Returns</strong></p><p>A branching table, which is a <a href="#OptimalBranchingCore.BranchingTable"><code>BranchingTable</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L101-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.candidate_clauses-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT" href="#OptimalBranchingCore.candidate_clauses-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT"><code>OptimalBranchingCore.candidate_clauses</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">candidate_clauses(tbl::BranchingTable{INT}) where {INT}</code></pre><p>Generates candidate clauses from a branching table.</p><p><strong>Arguments</strong></p><ul><li><code>tbl::BranchingTable{INT}</code>: The branching table containing bit strings.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Clause{INT}}</code>: A vector of <code>Clause</code> objects generated from the branching table.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.complexity_bv-Union{Tuple{Vector{T}}, Tuple{T}} where T" href="#OptimalBranchingCore.complexity_bv-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>OptimalBranchingCore.complexity_bv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">complexity_bv(branching_vector::Vector)::Float64</code></pre><p>Calculates the complexity that associated with the provided branching vector by solving the equation:</p><p class="math-container">\[γ^0 = \sum_{δρ \in \text{branching_vector}} γ^{-δρ}\]</p><p><strong>Arguments</strong></p><ul><li><code>branching_vector</code>: a vector of problem size reductions in the branches.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed γ value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}" href="#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}"><code>OptimalBranchingCore.covered_by</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covered_by(t::BranchingTable, dnf::DNF)</code></pre><p>Check if the branching table <code>t</code> is covered by the logic expression <code>dnf</code>. Returns <code>true</code> if there exists at least one bitstring in each group of <code>t</code> that satisfies <code>dnf</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/branching_table.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.covered_by-Tuple{Integer, Clause}" href="#OptimalBranchingCore.covered_by-Tuple{Integer, Clause}"><code>OptimalBranchingCore.covered_by</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covered_by(a::Integer, clause_or_dnf)</code></pre><p>Check if <code>a</code> is covered by the logic expression <code>clause_or_dnf</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: A bit string.</li><li><code>clause_or_dnf</code>: Logic expression, which can be a <a href="#OptimalBranchingCore.Clause"><code>Clause</code></a> object or a <a href="#OptimalBranchingCore.DNF"><code>DNF</code></a> object.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if <code>a</code> satisfies <code>clause_or_dnf</code>, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L84-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.is_false_literal-Tuple{Clause}" href="#OptimalBranchingCore.is_false_literal-Tuple{Clause}"><code>OptimalBranchingCore.is_false_literal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_false_literal(c::Clause)</code></pre><p>Check if the clause is a false literal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.is_true_literal-Tuple{Clause}" href="#OptimalBranchingCore.is_true_literal-Tuple{Clause}"><code>OptimalBranchingCore.is_true_literal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_true_literal(c::Clause)</code></pre><p>Check if the clause is a true literal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.literals-Tuple{Clause}" href="#OptimalBranchingCore.literals-Tuple{Clause}"><code>OptimalBranchingCore.literals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">literals(c::Clause)</code></pre><p>Return all literals in the clause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.measure" href="#OptimalBranchingCore.measure"><code>OptimalBranchingCore.measure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(problem::AbstractProblem, measure::AbstractMeasure)::Number</code></pre><p>Calculate the size of the problem, reducing which serves as the guiding principle for the branching strategy.</p><p><strong>Arguments</strong></p><ul><li><code>problem</code>: The problem instance.</li><li><code>measure</code>: The measure of the problem size.</li></ul><p><strong>Returns</strong></p><p>A real number representing the problem size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L31-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.minimize_γ-Union{Tuple{INT}, Tuple{BranchingTable, Array{Clause{INT}, 1}, Vector, AbstractSetCoverSolver}} where INT" href="#OptimalBranchingCore.minimize_γ-Union{Tuple{INT}, Tuple{BranchingTable, Array{Clause{INT}, 1}, Vector, AbstractSetCoverSolver}} where INT"><code>OptimalBranchingCore.minimize_γ</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimize_γ(table::BranchingTable, candidates::Vector{Clause}, Δρ::Vector, solver)</code></pre><p>Finds the optimal cover based on the provided vector of problem size reduction. This function implements a cover selection algorithm using an iterative process. It utilizes an integer programming solver to optimize the selection of sub-covers based on their complexity.</p><p><strong>Arguments</strong></p><ul><li><code>table::BranchingTable</code>: A branching table containing clauses that need to be covered, a table entry is covered by a clause if one of its bit strings satisfies the clause. Please refer to <a href="#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}"><code>covered_by</code></a> for more details.</li><li><code>candidates::Vector{Clause}</code>: A vector of candidate clauses to form the branching rule (in the form of <a href="#OptimalBranchingCore.DNF"><code>DNF</code></a>).</li><li><code>Δρ::Vector</code>: A vector of problem size reduction for each candidate clause.</li><li><code>solver</code>: The solver to be used. It can be an instance of <code>LPSolver</code> or <code>IPSolver</code>.</li></ul><p><strong>Returns</strong></p><p>A tuple of two elements: (indices of selected subsets, γ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L121-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.optimal_branching_rule-Tuple{BranchingTable, Vector, AbstractProblem, AbstractMeasure, AbstractSetCoverSolver}" href="#OptimalBranchingCore.optimal_branching_rule-Tuple{BranchingTable, Vector, AbstractProblem, AbstractMeasure, AbstractSetCoverSolver}"><code>OptimalBranchingCore.optimal_branching_rule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimal_branching_rule(table::BranchingTable, variables::Vector, problem::AbstractProblem, measure::AbstractMeasure, solver::AbstractSetCoverSolver)::OptimalBranchingResult</code></pre><p>Generate an optimal branching rule from a given branching table.</p><p><strong>Arguments</strong></p><ul><li><code>table</code>: A <a href="#OptimalBranchingCore.BranchingTable"><code>BranchingTable</code></a> instance containing candidate clauses.</li><li><code>variables</code>: A vector of variables to perform the branching.</li><li><code>problem</code>: The problem instance being solved.</li><li><code>measure</code>: The measure used for evaluating the problem size reduction in the branches.</li><li><code>solver</code>: The solver used for the weighted minimum set cover problem, which can be either <a href="#OptimalBranchingCore.LPSolver"><code>LPSolver</code></a> or <a href="#OptimalBranchingCore.IPSolver"><code>IPSolver</code></a>.</li></ul><p><strong>Returns</strong></p><p>A <a href="#OptimalBranchingCore.OptimalBranchingResult"><code>OptimalBranchingResult</code></a> object representing the optimal branching rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/branch.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.reduce_problem-Union{Tuple{T}, Tuple{Type{T}, AbstractProblem, NoReducer}} where T" href="#OptimalBranchingCore.reduce_problem-Union{Tuple{T}, Tuple{Type{T}, AbstractProblem, NoReducer}} where T"><code>OptimalBranchingCore.reduce_problem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reduce_problem(::Type{R}, problem::AbstractProblem, reducer::AbstractReducer) where R</code></pre><p>Reduces the problem size directly, e.g. by graph rewriting. It is a crucial step in the reduce and branch strategy.</p><p><strong>Arguments</strong></p><ul><li><code>R</code>: The element type used for computing the size of solution. The should have an additive commutative monoid structure.</li><li><code>problem</code>: The problem instance.</li><li><code>reducer</code>: The reducer.</li></ul><p><strong>Returns</strong></p><p>A tuple of two values:</p><ul><li><code>AbstractProblem</code>: A new instance of <code>AbstractProblem</code> with reduced size.</li><li><code>Number</code>: The local gain of the reduction, which will be added to the global gain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L54-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.select_variables" href="#OptimalBranchingCore.select_variables"><code>OptimalBranchingCore.select_variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_variables(problem::AbstractProblem, measure::AbstractMeasure, selector::AbstractSelector)::Vector{Int}</code></pre><p>Selects a branching strategy for a <code>AbstractProblem</code> instance. </p><p><strong>Arguments</strong></p><ul><li><code>problem</code>: The problem instance.</li><li><code>measure</code>: The measure of the problem size.</li><li><code>selector</code>: The variables selection strategy, which is a subtype of <a href="#OptimalBranchingCore.AbstractSelector"><code>AbstractSelector</code></a>.</li></ul><p><strong>Returns</strong></p><p>A vector of indices of the selected variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.weighted_minimum_set_cover-Tuple{LPSolver, AbstractVector, Vector{Vector{Int64}}, Int64}" href="#OptimalBranchingCore.weighted_minimum_set_cover-Tuple{LPSolver, AbstractVector, Vector{Vector{Int64}}, Int64}"><code>OptimalBranchingCore.weighted_minimum_set_cover</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_minimum_set_cover(solver, weights::AbstractVector, subsets::Vector{Vector{Int}}, num_items::Int)</code></pre><p>Solves the weighted minimum set cover problem.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: The solver to be used. It can be an instance of <code>LPSolver</code> or <code>IPSolver</code>.</li><li><code>weights::AbstractVector</code>: The weights of the subsets.</li><li><code>subsets::Vector{Vector{Int}}</code>: A vector of subsets.</li><li><code>num_items::Int</code>: The number of elements to cover.</li></ul><p><strong>Returns</strong></p><p>A vector of indices of selected subsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L216-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractMeasure" href="#OptimalBranchingCore.AbstractMeasure"><code>OptimalBranchingCore.AbstractMeasure</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMeasure</code></pre><p>The base type for the measure of the problem size in terms of computational hardness. Some widely used measures include the number of variables, the vertices with connectivity of at least 3, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractProblem" href="#OptimalBranchingCore.AbstractProblem"><code>OptimalBranchingCore.AbstractProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractProblem</code></pre><p>The problem type that can be used in the optimal branching framework.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractReducer" href="#OptimalBranchingCore.AbstractReducer"><code>OptimalBranchingCore.AbstractReducer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractReducer</code></pre><p>An abstract type representing a reducer in the context of branching problems.  This serves as a base type for all specific reducer implementations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractSelector" href="#OptimalBranchingCore.AbstractSelector"><code>OptimalBranchingCore.AbstractSelector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSelector</code></pre><p>An abstract type for the strategy of selecting a subset of variables to be branched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractSetCoverSolver" href="#OptimalBranchingCore.AbstractSetCoverSolver"><code>OptimalBranchingCore.AbstractSetCoverSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSetCoverSolver</code></pre><p>An abstract type for the strategy of solving the set covering problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.AbstractTableSolver" href="#OptimalBranchingCore.AbstractTableSolver"><code>OptimalBranchingCore.AbstractTableSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTableSolver</code></pre><p>An abstract type for the strategy of obtaining the branching table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/interfaces.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.BranchingStrategy" href="#OptimalBranchingCore.BranchingStrategy"><code>OptimalBranchingCore.BranchingStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BranchingStrategy
BranchingStrategy(; kwargs...)</code></pre><p>A struct representing the configuration for a solver, including the reducer and branching strategy.</p><p><strong>Fields</strong></p><ul><li><code>table_solver::AbstractTableSolver</code>: The solver to resolve the relevant bit strings and generate a branching table.</li><li><code>set_cover_solver::AbstractSetCoverSolver = IPSolver()</code>: The solver to solve the set covering problem.</li><li><code>selector::AbstractSelector</code>: The selector to select the next branching variable or decision.</li><li><code>m::AbstractMeasure</code>: The measure to evaluate the performance of the branching strategy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/branch.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.BranchingTable" href="#OptimalBranchingCore.BranchingTable"><code>OptimalBranchingCore.BranchingTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BranchingTable{INT &lt;: Integer}</code></pre><p>A list of groupped bitstrings, which is used for designing the branching rule. A valid branching rule, which is represented by a logic expression in Disjunctive Normal Form (DNF), should cover at least one bitstring from each group, where by <code>cover</code>, we mean there exists at least one bitstring in the group that satisfies the logic expression. Please check <a href="#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}"><code>covered_by</code></a> for more details.</p><p><strong>Fields</strong></p><ul><li><code>bit_length::Int</code>: The length of the bit string.</li><li><code>table::Vector{Vector{INT}}</code>: The list of groupped bitstrings used for branching, where each group is a vector of bitstrings. The bitstrings uses <code>INT</code> type to store the bitstring.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/branching_table.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.CandidateClause" href="#OptimalBranchingCore.CandidateClause"><code>OptimalBranchingCore.CandidateClause</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CandidateClause{INT &lt;: Integer}</code></pre><p>A candidate clause is a clause containing the formation related to how it can cover the items in the branching table.</p><p><strong>Fields</strong></p><ul><li><code>covered_items::Set{Int}</code>: The items in the branching table that are covered by the clause.</li><li><code>clause::Clause{INT}</code>: The clause itself.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.Clause" href="#OptimalBranchingCore.Clause"><code>OptimalBranchingCore.Clause</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Clause{INT &lt;: Integer}</code></pre><p>A Clause is conjunction of literals, which is specified by a pair of bit strings. The type parameter <code>INT</code> is the integer type for storing the bit strings.</p><p><strong>Fields</strong></p><ul><li><code>mask</code>: A bit string that indicates the variables involved in the clause.</li><li><code>val</code>: A bit string that indicates the positive literals in the clause.</li></ul><p><strong>Examples</strong></p><p>To check if a bit string satisfies a clause, use <code>OptimalBranchingCore.covered_by</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using OptimalBranchingCore

julia&gt; clause = Clause(0b1110, 0b1010)
Clause{UInt8}: #2 ∧ ¬#3 ∧ #4

julia&gt; OptimalBranchingCore.covered_by(0b1110, clause)
false

julia&gt; OptimalBranchingCore.covered_by(0b1010, clause)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.DNF" href="#OptimalBranchingCore.DNF"><code>OptimalBranchingCore.DNF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DNF{INT}</code></pre><p>A data structure representing a logic expression in Disjunctive Normal Form (DNF), which is a disjunction of one or more conjunctions of literals. In OptimalBranchingCore, a DNF is used to represent the branching rule.</p><p><strong>Fields</strong></p><ul><li><code>clauses::Vector{Clause{INT}}</code>: A vector of <code>Clause</code> objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/bitbasis.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.IPSolver" href="#OptimalBranchingCore.IPSolver"><code>OptimalBranchingCore.IPSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IPSolver &lt;: AbstractSetCoverSolver
IPSolver(; optimizer = HiGHS.Optimizer, max_itr::Int = 20, γ0::Float64 = 2.0, verbose::Bool = false)</code></pre><p>An integer programming solver for set covering problems.</p><p><strong>Fields</strong></p><ul><li><code>optimizer</code>: The optimizer to be used.</li><li><code>max_itr::Int</code>: The maximum number of iterations to be performed.</li><li><code>γ0::Float64</code>: The initial γ value.</li><li><code>verbose::Bool</code>: Whether to print the solver&#39;s output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.LPSolver" href="#OptimalBranchingCore.LPSolver"><code>OptimalBranchingCore.LPSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LPSolver &lt;: AbstractSetCoverSolver
LPSolver(; optimizer = HiGHS.Optimizer, max_itr::Int = 20, γ0::Float64 = 2.0, verbose::Bool = false)</code></pre><p>A linear programming solver for set covering problems.</p><p><strong>Fields</strong></p><ul><li><code>optimizer</code>: The optimizer to be used.</li><li><code>max_itr::Int</code>: The maximum number of iterations to be performed.</li><li><code>γ0::Float64</code>: The initial γ value.</li><li><code>verbose::Bool</code>: Whether to print the solver&#39;s output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.MaxSize" href="#OptimalBranchingCore.MaxSize"><code>OptimalBranchingCore.MaxSize</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaxSize</code></pre><p>A struct representing the maximum size of a result. (actually a tropical int)</p><p><strong>Fields</strong></p><ul><li><code>size::Int</code>: The maximum size value.</li></ul><p><strong>Constructors</strong></p><ul><li><code>MaxSize(size::Int)</code>: Creates a <code>MaxSize</code> instance with the specified size.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/algebra.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.MaxSizeBranchCount" href="#OptimalBranchingCore.MaxSizeBranchCount"><code>OptimalBranchingCore.MaxSizeBranchCount</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MaxSizeBranchCount</code></pre><p>Reture both the max size of the results and number of branches.</p><p><strong>Fields</strong></p><ul><li><code>size::Int</code>: The max size of the results.</li><li><code>count::Int</code>: The number of branches of that size.</li></ul><p><strong>Constructors</strong></p><ul><li><code>MaxSizeBranchCount(size::Int)</code>: Creates a <code>MaxSizeBranchCount</code> with the given size and initializes the count to 1.</li><li><code>MaxSizeBranchCount(size::Int, count::Int)</code>: Creates a <code>MaxSizeBranchCount</code> with the specified size and count.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/algebra.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.MockTableSolver" href="#OptimalBranchingCore.MockTableSolver"><code>OptimalBranchingCore.MockTableSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MockTableSolver &lt;: AbstractTableSolver</code></pre><p>The <code>MockTableSolver</code> randomly generates a branching table with a given number of rows. Each row must have at least one variable to be covered by the branching rule.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: The number of rows in the branching table.</li><li><code>p::Float64 = 0.0</code>: The probability of generating more than one variables in a row, following the Poisson distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/mockproblem.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.NumOfVariables" href="#OptimalBranchingCore.NumOfVariables"><code>OptimalBranchingCore.NumOfVariables</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NumOfVariables</code></pre><p>A struct representing a measure that counts the number of variables in a problem.  Each variable is counted as 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/mockproblem.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.OptimalBranchingResult" href="#OptimalBranchingCore.OptimalBranchingResult"><code>OptimalBranchingCore.OptimalBranchingResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OptimalBranchingResult{INT &lt;: Integer}</code></pre><p>The result type for the optimal branching rule.</p><p><strong>Fields</strong></p><ul><li><code>optimal_rule::DNF{INT}</code>: The optimal branching rule.</li><li><code>branching_vector::Vector{T&lt;:Real}</code>: The branching vector that records the size reduction in each subproblem.</li><li><code>γ::Float64</code>: The optimal γ value (the complexity of the branching rule).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/setcovering.jl#L102-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OptimalBranchingCore.RandomSelector" href="#OptimalBranchingCore.RandomSelector"><code>OptimalBranchingCore.RandomSelector</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct RandomSelector &lt;: AbstractSelector</code></pre><p>The <code>RandomSelector</code> struct represents a strategy for selecting a subset of variables randomly.</p><p><strong>Fields</strong></p><ul><li><code>n::Int</code>: The number of variables to select.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalBranching/OptimalBranching.jl/blob/ad1db704ea495e2a1e51f72041ba7d506bab8c99/lib/OptimalBranchingCore/src/mockproblem.jl#L15-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../performance_tips/">« Performance Tips</a><a class="docs-footer-nextpage" href="../mis/">OptimalBranchingMIS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 7 March 2025 17:19">Friday 7 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
