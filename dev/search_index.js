var documenterSearchIndex = {"docs":
[{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"CurrentModule = OptimalBranchingCore\nDocTestSetup = quote\n    using OptimalBranching\n    using OptimalBranchingCore\n    using BitBasis\nend","category":"page"},{"location":"man/core/#core","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"","category":"section"},{"location":"man/core/#Literal,-Clause-and-DNF","page":"OptimalBranchingCore","title":"Literal, Clause and DNF","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Literals, clauses and disjunctive normal form (DNF) are basic concepts in boolean logic, where literals are boolean variables, clauses are boolean expressions, and DNF is a disjunction of one or more conjunctions of literals.","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Here is an example, given a truth table as follows:","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"a b c value\n0 0 0 1\n0 0 1 1\n0 1 0 0\n0 1 1 0\n1 0 0 0\n1 0 1 1\n1 1 0 0\n1 1 1 0","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"where a b c are boolean variables called literals. The true statements can be represented as a conjunction of literals, for example, ","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"neg a land neg b land neg c neg a land neg b land c a land neg b land c","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"and these clauses can be combined into a DNF:","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"(neg a land neg b) lor (a land neg b land c)","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"In OptimalBranchingCore, a clause is represented by the Clause type, and a DNF is represented by the DNF type, based on the BitBasis.jl package.","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"using OptimalBranchingCore, BitBasis\nc1 = Clause(bit\"011\", bit\"000\")\nc2 = Clause(bit\"111\", bit\"101\")\ndnf = DNF(c1, c2)","category":"page"},{"location":"man/core/#The-branch-and-bound-algorithm","page":"OptimalBranchingCore","title":"The branch and bound algorithm","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"The branch and bound algorithm is a method to exactly solve the combinatorial optimization problems.","category":"page"},{"location":"man/core/#API","page":"OptimalBranchingCore","title":"API","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Modules = [OptimalBranchingCore]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/core/#OptimalBranchingCore.apply_branch","page":"OptimalBranchingCore","title":"OptimalBranchingCore.apply_branch","text":"apply_branch(problem::AbstractProblem, clause::Clause, vertices::Vector)::Tuple\n\nCreate a branch from the given clause applied to the specified vertices.\n\nArguments\n\nproblem: The problem instance.\nclause: The clause that containing the information about how to fix the values of the variables.\nvertices: A vector of vertices to be considered for the branch.\n\nReturns\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.branch_and_reduce-Tuple{AbstractProblem, BranchingStrategy, AbstractReducer, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branch_and_reduce","text":"branch_and_reduce(problem::AbstractProblem, config::BranchingStrategy; reducer::AbstractReducer=NoReducer(), result_type=Int)\n\nBranch the given problem using the specified solver configuration.\n\nArguments\n\nproblem: The problem instance to solve.\nconfig: The configuration for the solver, which is a BranchingStrategy instance.\n\nKeyword Arguments\n\nreducer::AbstractReducer=NoReducer(): The reducer to reduce the problem size.\nresult_type::Type{TR}: The type of the result that the solver will produce.\n\nReturns\n\nThe resulting value, which may have different type depending on the result_type.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.branching_table","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branching_table","text":"branching_table(problem::AbstractProblem, table_solver::AbstractTableSolver, variables::Vector{Int})\n\nObtains the branching table for a given problem using a specified table solver.\n\nArguments\n\nproblem: The problem instance.\ntable_solver: The table solver, which is a subtype of AbstractTableSolver.\nvariables: A vector of indices of the variables to be considered for the branching table.\n\nReturns\n\nA branching table, which is a BranchingTable object.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.candidate_clauses-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.candidate_clauses","text":"candidate_clauses(tbl::BranchingTable{INT}) where {INT}\n\nGenerates candidate clauses from a branching table.\n\nArguments\n\ntbl::BranchingTable{INT}: The branching table containing bit strings.\n\nReturns\n\nVector{Clause{INT}}: A vector of Clause objects generated from the branching table.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.complexity_bv-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.complexity_bv","text":"complexity_bv(branching_vector::Vector)::Float64\n\nCalculates the complexity that associated with the provided branching vector by solving the equation:\n\nγ^0 = sum_δρ in textbranching_vector γ^-δρ\n\nArguments\n\nbranching_vector: a vector of problem size reductions in the branches.\n\nReturns\n\nFloat64: The computed γ value.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(t::BranchingTable, dnf::DNF)\n\nCheck if the branching table t is covered by the logic expression dnf. Returns true if there exists at least one bitstring in each group of t that satisfies dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{Integer, Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(a::Integer, clause_or_dnf)\n\nCheck if a is covered by the logic expression clause_or_dnf.\n\nArguments\n\na: A bit string.\nclause_or_dnf: Logic expression, which can be a Clause object or a DNF object.\n\nReturns\n\ntrue if a satisfies clause_or_dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_false_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_false_literal","text":"is_false_literal(c::Clause)\n\nCheck if the clause is a false literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_true_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_true_literal","text":"is_true_literal(c::Clause)\n\nCheck if the clause is a true literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.literals-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.literals","text":"literals(c::Clause)\n\nReturn all literals in the clause.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.measure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.measure","text":"measure(problem::AbstractProblem, measure::AbstractMeasure)::Number\n\nCalculate the size of the problem, reducing which serves as the guiding principle for the branching strategy.\n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\n\nReturns\n\nA real number representing the problem size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.minimize_γ-Union{Tuple{INT}, Tuple{BranchingTable, Array{Clause{INT}, 1}, Vector, AbstractSetCoverSolver}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.minimize_γ","text":"minimize_γ(table::BranchingTable, candidates::Vector{Clause}, Δρ::Vector, solver)\n\nFinds the optimal cover based on the provided vector of problem size reduction. This function implements a cover selection algorithm using an iterative process. It utilizes an integer programming solver to optimize the selection of sub-covers based on their complexity.\n\nArguments\n\ntable::BranchingTable: A branching table containing clauses that need to be covered, a table entry is covered by a clause if one of its bit strings satisfies the clause. Please refer to covered_by for more details.\ncandidates::Vector{Clause}: A vector of candidate clauses to form the branching rule (in the form of DNF).\nΔρ::Vector: A vector of problem size reduction for each candidate clause.\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\n\nKeyword Arguments\n\nγ0::Float64: The initial γ value.\n\nReturns\n\nA tuple of two elements: (indices of selected subsets, γ)\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.optimal_branching_rule-Tuple{BranchingTable, Vector, AbstractProblem, AbstractMeasure, AbstractSetCoverSolver}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.optimal_branching_rule","text":"optimal_branching_rule(table::BranchingTable, variables::Vector, problem::AbstractProblem, measure::AbstractMeasure, solver::AbstractSetCoverSolver)::OptimalBranchingResult\n\nGenerate an optimal branching rule from a given branching table.\n\nArguments\n\ntable: A BranchingTable instance containing candidate clauses.\nvariables: A vector of variables to perform the branching.\nproblem: The problem instance being solved.\nmeasure: The measure used for evaluating the problem size reduction in the branches.\nsolver: The solver used for the weighted minimum set cover problem, which can be either LPSolver or IPSolver.\n\nReturns\n\nA OptimalBranchingResult object representing the optimal branching rule.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.reduce_problem-Union{Tuple{T}, Tuple{Type{T}, AbstractProblem, NoReducer}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, problem::AbstractProblem, reducer::AbstractReducer) where R\n\nReduces the problem size directly, e.g. by graph rewriting. It is a crucial step in the reduce and branch strategy.\n\nArguments\n\nR: The element type used for computing the size of solution. The should have an additive commutative monoid structure.\nproblem: The problem instance.\nreducer: The reducer.\n\nReturns\n\nA tuple of two values:\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\nNumber: The local gain of the reduction, which will be added to the global gain.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.select_variables","page":"OptimalBranchingCore","title":"OptimalBranchingCore.select_variables","text":"select_variables(problem::AbstractProblem, measure::AbstractMeasure, selector::AbstractSelector)::Vector{Int}\n\nSelects a branching strategy for a AbstractProblem instance. \n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\nselector: The variables selection strategy, which is a subtype of AbstractSelector.\n\nReturns\n\nA vector of indices of the selected variables.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.weighted_minimum_set_cover-Tuple{LPSolver, AbstractVector, Vector{Vector{Int64}}, Int64}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.weighted_minimum_set_cover","text":"weighted_minimum_set_cover(solver, weights::AbstractVector, subsets::Vector{Vector{Int}}, num_items::Int)\n\nSolves the weighted minimum set cover problem.\n\nArguments\n\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\nweights::AbstractVector: The weights of the subsets.\nsubsets::Vector{Vector{Int}}: A vector of subsets.\nnum_items::Int: The number of elements to cover.\n\nReturns\n\nA vector of indices of selected subsets.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.AbstractMeasure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractMeasure","text":"AbstractMeasure\n\nThe base type for the measure of the problem size in terms of computational hardness. Some widely used measures include the number of variables, the vertices with connectivity of at least 3, etc.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractProblem","text":"AbstractProblem\n\nThe problem type that can be used in the optimal branching framework.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractReducer","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractReducer","text":"AbstractReducer\n\nAn abstract type representing a reducer in the context of branching problems.  This serves as a base type for all specific reducer implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSelector","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSelector","text":"AbstractSelector\n\nAn abstract type for the strategy of selecting a subset of variables to be branched.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSetCoverSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSetCoverSolver","text":"AbstractSetCoverSolver\n\nAn abstract type for the strategy of solving the set covering problem.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractTableSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractTableSolver","text":"AbstractTableSolver\n\nAn abstract type for the strategy of obtaining the branching table.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingStrategy","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingStrategy","text":"BranchingStrategy\nBranchingStrategy(; kwargs...)\n\nA struct representing the configuration for a solver, including the reducer and branching strategy.\n\nFields\n\ntable_solver::AbstractTableSolver: The solver to resolve the relevant bit strings and generate a branching table.\nset_cover_solver::AbstractSetCoverSolver = IPSolver(): The solver to solve the set covering problem.\nselector::AbstractSelector: The selector to select the next branching variable or decision.\nm::AbstractMeasure: The measure to evaluate the performance of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingTable","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingTable","text":"BranchingTable{INT <: Integer}\n\nA list of groupped bitstrings, which is used for designing the branching rule. A valid branching rule, which is represented by a logic expression in Disjunctive Normal Form (DNF), should cover at least one bitstring from each group, where by cover, we mean there exists at least one bitstring in the group that satisfies the logic expression. Please check covered_by for more details.\n\nFields\n\nbit_length::Int: The length of the bit string.\ntable::Vector{Vector{INT}}: The list of groupped bitstrings used for branching, where each group is a vector of bitstrings. The bitstrings uses INT type to store the bitstring.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.CandidateClause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.CandidateClause","text":"CandidateClause{INT <: Integer}\n\nA candidate clause is a clause containing the formation related to how it can cover the items in the branching table.\n\nFields\n\ncovered_items::Set{Int}: The items in the branching table that are covered by the clause.\nclause::Clause{INT}: The clause itself.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.Clause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.Clause","text":"Clause{INT <: Integer}\n\nA Clause is conjunction of literals, which is specified by a pair of bit strings. The type parameter INT is the integer type for storing the bit strings.\n\nFields\n\nmask: A bit string that indicates the variables involved in the clause.\nval: A bit string that indicates the positive literals in the clause.\n\nExamples\n\nTo check if a bit string satisfies a clause, use OptimalBranchingCore.covered_by.\n\njulia> using OptimalBranchingCore\n\njulia> clause = Clause(0b1110, 0b1010)\nClause{UInt8}: #2 ∧ ¬#3 ∧ #4\n\njulia> OptimalBranchingCore.covered_by(0b1110, clause)\nfalse\n\njulia> OptimalBranchingCore.covered_by(0b1010, clause)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.DNF","page":"OptimalBranchingCore","title":"OptimalBranchingCore.DNF","text":"DNF{INT}\n\nA data structure representing a logic expression in Disjunctive Normal Form (DNF), which is a disjunction of one or more conjunctions of literals. In OptimalBranchingCore, a DNF is used to represent the branching rule.\n\nFields\n\nclauses::Vector{Clause{INT}}: A vector of Clause objects.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.IPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.IPSolver","text":"IPSolver <: AbstractSetCoverSolver\nIPSolver(; max_itr::Int = 5, verbose::Bool = false)\n\nAn integer programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations to be performed.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.LPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.LPSolver","text":"LPSolver <: AbstractSetCoverSolver\nLPSolver(; max_itr::Int = 5, verbose::Bool = false)\n\nA linear programming solver for set covering problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations to be performed.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSize","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSize","text":"MaxSize\n\nA struct representing the maximum size of a result. (actually a tropical int)\n\nFields\n\nsize::Int: The maximum size value.\n\nConstructors\n\nMaxSize(size::Int): Creates a MaxSize instance with the specified size.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSizeBranchCount","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSizeBranchCount","text":"struct MaxSizeBranchCount\n\nReture both the max size of the results and number of branches.\n\nFields\n\nsize::Int: The max size of the results.\ncount::Int: The number of branches of that size.\n\nConstructors\n\nMaxSizeBranchCount(size::Int): Creates a MaxSizeBranchCount with the given size and initializes the count to 1.\nMaxSizeBranchCount(size::Int, count::Int): Creates a MaxSizeBranchCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.OptimalBranchingResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.OptimalBranchingResult","text":"OptimalBranchingResult{INT <: Integer}\n\nThe result type for the optimal branching rule.\n\nFields\n\nselected_ids::Vector{Int}: The indices of the selected rows in the branching table.\noptimal_rule::DNF{INT}: The optimal branching rule.\nbranching_vector::Vector{T<:Real}: The branching vector that records the size reduction in each subproblem.\nγ::Float64: The optimal γ value (the complexity of the branching rule).\n\n\n\n\n\n","category":"type"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/#The-maximum-independent-set-problem","page":"Benchmarks","title":"The maximum independent set problem","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We benchmarked the branch-and-reduce algorithm based on the optimal branching algorithm on the maximum independent set problem against various state-of-the-art solvers, where we compared the number of branches needed to solve the problem.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our mehtod is denoted as textttob and textttob+xiao, and the previous method include textttxiao2013 and textttakiba2015. We compared the performance of these methods in 3-regular graphs, Erdős–Rényi random graphs, grid graphs and King's sub-graphs, for each size we generated 1000 random graphs.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The average number of branches needed to solve the problem is shown in the following figure:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: )","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The maximum number of branches needed to solve the problem among 1000 graphs is shown in the following figure:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: )","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These numerical results show that our method is competitive with the previous methods with less human-designed rules.","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"EditURL = \"../../../examples/rule_discovery.jl\"","category":"page"},{"location":"generated/rule_discovery/#Automatic-rule-discovery","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"using OptimalBranching.OptimalBranchingMIS.Graphs, OptimalBranching\nusing OptimalBranching.OptimalBranchingCore, OptimalBranching.OptimalBranchingCore.BitBasis","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"This function generates the tree-like N3 neighborhood of g0.","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"function tree_like_N3_neighborhood(g0::SimpleGraph)\n    g = copy(g0)\n    for layer in 1:3\n        for v in vertices(g)\n            for _ = 1:(3-degree(g, v))\n                add_vertex!(g)\n                add_edge!(g, v, nv(g))\n            end\n        end\n    end\n    return g\nend\n\nfunction solve_opt_rule(branching_region, graph, vs)\n    # Use default solver and measure\n    m = D3Measure()\n    table_solver = TensorNetworkSolver(; prune_by_env=true)\n    set_cover_solver = IPSolver()\n\n    # Pruning irrelevant entries\n    ovs = OptimalBranchingMIS.open_vertices(graph, vs)\n    subg, vmap = induced_subgraph(graph, vs)\n    @info \"solving the branching table...\"\n    tbl = OptimalBranchingMIS.reduced_alpha_configs(table_solver, subg, Int[findfirst(==(v), vs) for v in ovs])\n    @info \"the length of the truth_table after pruning irrelevant entries: $(length(tbl.table))\"\n\n    @info \"generating candidate clauses...\"\n    candidate_clauses = collect(OptimalBranchingMIS.OptimalBranchingCore.candidate_clauses(tbl))\n    @info \"the length of the candidate clauses: $(length(candidate_clauses))\"\n\n    @info \"generating the optimal branching rule via set cover...\"\n    problem = MISProblem(graph)\n    size_reductions = [measure(problem, m) - measure(first(OptimalBranchingCore.apply_branch(problem, candidate, vs)), m) for candidate in candidate_clauses]\n    result = OptimalBranchingMIS.OptimalBranchingCore.minimize_γ(tbl, candidate_clauses, size_reductions, set_cover_solver; γ0=2.0)\n    @info \"the minimized gamma: $(result.γ)\"\n\n    @info \"the optimal branching rule on R:\"\n    viz_dnf(result.optimal_rule, vs)\nend\n\nfunction viz_dnf(dnf::DNF{INT}, variables::Vector{T}) where {T, INT}\n    for c in dnf.clauses\n        println(join([iszero(readbit(c.val, i)) ? \"¬$(variables[i])\" : \"$(variables[i])\" for i = 1:bsizeof(INT) if readbit(c.mask, i) == 1], \" ∧ \"))\n    end\nend","category":"page"},{"location":"generated/rule_discovery/#Domination-rule","page":"Automatic rule discovery","title":"Domination rule","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5]\nedges = [(1, 2), (2, 3), (1, 3), (2, 4), (3, 4), (2, 5), (4, 5)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))\n\ngraph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/#PH2-rule","page":"Automatic rule discovery","title":"PH2 rule","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5,6,7,8]\nedges = [(1, 2), (1, 5), (2, 3), (2, 6), (3, 4), (4, 5), (5, 8), (6, 7), (7, 8)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Generate the tree-like N3 neighborhood of R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"graph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/#Bottleneck-case","page":"Automatic rule discovery","title":"Bottleneck case","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]\nedges = [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10), (5, 11), (5, 12), (6, 13), (6, 14), (7, 15), (7, 16), (8, 17), (8, 18), (9, 19), (9, 20), (10, 21), (10, 22), (11, 14), (12, 13), (15, 18), (16, 17), (19, 22), (20, 21)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Generate the tree-like N3 neighborhood of R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"graph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"CurrentModule = OptimalBranchingMIS","category":"page"},{"location":"man/mis/#OptimalBranchingMIS","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"","category":"section"},{"location":"man/mis/#The-maximum-independent-set-problem","page":"OptimalBranchingMIS","title":"The maximum independent set problem","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"The maximum independent set problem is a classical combinatorial optimization problem, which is to find the largest subset of vertices in a graph such that no two vertices in the subset are adjacent.","category":"page"},{"location":"man/mis/#Designing-a-branch-and-reduce-algorithm-using-the-optimal-branching-algorithm","page":"OptimalBranchingMIS","title":"Designing a branch-and-reduce algorithm using the optimal branching algorithm","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"To solve the MIS problem, we use the framework provided by the OptimalBranchingCore package to design a branch-and-reduce algorithm.","category":"page"},{"location":"man/mis/#API","page":"OptimalBranchingMIS","title":"API","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Modules = [OptimalBranchingMIS]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, D3Measure}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::D3Measure)\n\nCalculates the D3 measure for the given MISProblem, which is defined as the sum of  the maximum degree of each vertex minus 2, for all vertices in the graph.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The computed D3 measure value.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, NumOfVertices}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::NumOfVertices)\n\nCalculates the number of vertices in the given MISProblem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The number of vertices in the graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.reduce_problem-Union{Tuple{R}, Tuple{Type{R}, MISProblem, MISReducer}} where R","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, p::MISProblem, ::MISReducer) where R\n\nReduces the given MISProblem by removing vertices based on their degrees and returns a new MISProblem instance along with the count of removed vertices.\n\nArguments\n\np::MISProblem: The problem instance containing the graph to be reduced.\n::MISReducer: An instance of the MISReducer struct.\n::Type{R}: The type of the result expected.\n\nReturns\n\nA tuple containing:\nA new MISProblem instance with specified vertices removed.\nAn integer representing the count of removed vertices.\n\nDescription\n\nThe function checks the number of vertices in the graph:\n\nIf there are no vertices, it returns an empty instance and a count of 0.\nIf there is one vertex, it returns an empty instance and a count of 1.\nIf there are two vertices, it returns an empty instance and a count based on the presence of an edge between them.\nFor graphs with more than two vertices, it calculates the degrees of the vertices and identifies the vertex with the minimum degree to determine which vertices to remove.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.closed_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.closed_neighbors","text":"closed_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a set of vertices that includes the input vertices as well as their open neighbors.\n\nArguments\n\ng::SimpleGraph: The input graph.\nvertices::Vector{Int}: The vertices for which closed neighbors are to be computed.\n\nReturns\n\nA set of vertices that includes the input vertices as well as their open neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis1-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis1","text":"counting_mis1(g::SimpleGraph)\n\nCalculates the maximum independent set (MIS) for a given SimpleGraph by first converting it into an EliminateGraph and then applying the counting_mis1 function.\n\nArguments\n\ng::SimpleGraph: The input graph for which the maximum independent set is to be calculated.\n\nReturns\n\nMISCount: The size of the maximum independent set for the provided graph and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis2-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis2","text":"counting_mis2(g::SimpleGraph)\n\nCalculates the size of the maximum independent set and the count of branches for a given SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_xiao2013-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_xiao2013","text":"counting_xiao2013(g::SimpleGraph)\n\nThis function counts the maximum independent set (MIS) in a given simple graph using the Xiao 2013 algorithm.\n\nArguments\n\ng::SimpleGraph: A simple graph for which the maximum independent set is to be counted.\n\nReturns\n\nCountingMIS: An object representing the size of the maximum independent set and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_branch_count-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_branch_count","text":"mis_branch_count(g::AbstractGraph; bs::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundaryHighDegreeSelector(2, 6, 0), measure=D3Measure()), reducer=MISReducer())\n\nCalculate the size and the number of branches of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size and the number of branches are to be calculated.\nbs::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundaryHighDegreeSelector(2, 6, 0), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\n\nReturns\n\nA tuple (size, count) where size is the size of the Maximum Independent Set and count is the number of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_size-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_size","text":"mis_size(g::AbstractGraph; bs::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundaryHighDegreeSelector(2, 6, 0), measure=D3Measure()), reducer::AbstractReducer = MISReducer())\n\nCalculate the size of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size is to be calculated.\nbs::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundaryHighDegreeSelector(2, 6, 0), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\n\nReturns\n\nAn integer representing the size of the Maximum Independent Set for the given graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbor_cover-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbor_cover","text":"neighbor_cover(g::SimpleGraph, v::Int, k::Int)\n\nCompute the neighbor cover of a vertex in a graph.\n\nArguments\n\ng::SimpleGraph: The input graph.\nv::Int: The vertex for which to compute the neighbor cover.\nk::Int: The number of iterations to perform.\n\nReturns\n\nvertices: An array containing the vertices in the neighbor cover.\nopenvertices: An array containing the open vertices in the neighbor cover.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbors_2nd-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbors_2nd","text":"neighbors_2nd(g::SimpleGraph, v::Int)\n\nReturn the second-order neighbors of a vertex v in a simple graph g.\n\nArguments\n\ng::SimpleGraph: The simple graph.\nv::Int: The vertex.\n\nReturns\n\nArray{Int}: An array of second-order neighbors of v.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_neighbors","text":"open_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a vector of vertices in the graph g, which are neighbors of the given vertices and not in the given vertices.\n\nArguments\n\ng::SimpleGraph: The graph in which to find the open neighbors.\nvertices::Vector{Int}: The vertices for which to find the open neighbors.\n\nReturns\n\nA vector of open neighbors of the given vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_vertices-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_vertices","text":"open_vertices(g::SimpleGraph, vertices::Vector{Int})\n\nRemove vertices from the given vector that are connected to all other vertices in the graph.\n\nArguments\n\ng::SimpleGraph: The graph object.\nvertices::Vector{Int}: The vector of vertices.\n\nReturns\n\nVector{Int}: The open vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.removed_vertices-Union{Tuple{N}, Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleGraph, Clause{N}}} where N","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.removed_vertices","text":"removed_vertices(vertices::Vector{Int}, g::SimpleGraph, clause::Clause{N}) where N\n\nGiven a list of vertices, a graph, and a clause, this function returns a list of removed vertices. \n\nThe vertices argument is a vector of integers representing the vertices to consider.  The g argument is a SimpleGraph object representing the graph. The clause argument is a Clause object representing a clause.\n\nThe function iterates over the vertices and checks if the corresponding bit in the clause.mask is 1.  If it is, the vertex is added to the list of removed vertices (rvs).  If the corresponding bit in the clause.val is also 1, the neighbors of the vertex are also added to rvs.\n\nThe function returns the list of removed vertices with duplicates removed.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.D3Measure","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.D3Measure","text":"D3Measure\n\nA struct representing a measure that calculates the sum of the maximum degree minus 2 for each vertex in the graph.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISCount","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISCount","text":"struct MISCount\n\nRepresents the count of Maximum Independent Sets (MIS).\n\nFields\n\nmis_size::Int: The size of the Maximum Independent Set.\nmis_count::Int: The number of Maximum Independent Sets of that size.\n\nConstructors\n\nMISCount(mis_size::Int): Creates a MISCount with the given size and initializes the count to 1.\nMISCount(mis_size::Int, mis_count::Int): Creates a MISCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISProblem","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISProblem","text":"mutable struct MISProblem <: AbstractProblem\n\nRepresents a Maximum Independent Set (MIS) problem.\n\nFields\n\ng::SimpleGraph: The graph associated with the MIS problem.\n\nMethods\n\ncopy(p::MISProblem): Creates a copy of the given MISProblem.\nBase.show(io::IO, p::MISProblem): Displays the number of vertices in the MISProblem.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISReducer","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISReducer","text":"MISReducer\n\nA struct representing a reducer for the Maximum Independent Set (MIS) problem.  This struct serves as a specific implementation of the AbstractReducer type.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundaryHighDegreeSelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundaryHighDegreeSelector","text":"struct MinBoundaryHighDegreeSelector <: AbstractVertexSelector\n\nThe MinBoundaryHighDegreeSelector struct represents a strategy:     - if exists a vertex with degree geq highdegreethreshold, then select it and its k-degree neighbors.     - otherwise, select a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nkb::Int: The number of layers of neighbors to consider when selecting the subgraph.\nhd::Int: The threshold of degree for a vertex to be selected.\nkd::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundarySelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundarySelector","text":"struct MinBoundarySelector <: AbstractVertexSelector\n\nThe MinBoundarySelector struct represents a strategy for selecting a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nk::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.NumOfVertices","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.NumOfVertices","text":"NumOfVertices\n\nA struct representing a measure that counts the number of vertices in a graph.  Each vertex is counted as 1.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.TensorNetworkSolver","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.TensorNetworkSolver","text":"TensorNetworkSolver\nTensorNetworkSolver(; prune_by_env::Bool = true)\n\nA struct representing a solver for tensor network problems.  This struct serves as a specific implementation of the AbstractTableSolver type.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBranching","category":"page"},{"location":"#OptimalBranching.jl","page":"Home","title":"OptimalBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to OptimalBranching. OptimalBranching.jl is a Julia package for automatic generation of optimal branching rule for the branch-and-bound algorithm.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, one can press ] to enter the package mode and enter","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ArrogantGao/OptimalBranching.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the latest version of the package, you can compile the source code locally by","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/ArrogantGao/OptimalBranching.jl\n$ cd OptimalBranching.jl\n$ make","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will add the submodules OptimalBranchingCore.jl and OptimalBranchingMIS.jl and install the dependencies, the tests will be run automatically to ensure everything is fine.","category":"page"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The relation between the submodules and the package is shown in the following diagram:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OptimalBranchingCore.jl --> OptimalBranchingMIS.jl --> OptimalBranching.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"where OptimalBranchingCore.jl contains the core algorithms, which convert the problem of searching the optimal branching rule into the problem of searching the optimal set cover, and OptimalBranchingMIS.jl is developed base on the optimal branching algorithms to solve the maximum independent set (MIS) problem, and OptimalBranching.jl is a package interface.","category":"page"},{"location":"#Quick-Starts","page":"Home","title":"Quick Starts","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can learn how to use OptimalBranching.jl with some quick examples in this section. The examples are about how to use the current implemented optimal branching algorithms to solve the maximum independent set (MIS) problem, and a brief introduction about extending the package to other method and problem will be provided.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note: This part is working in progress, for more details, please refer to the paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/core.md\",\n    \"man/mis.md\",\n]\nDepth = 1","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find any bug or have any suggestion, please open an issue.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this package useful in your research, please cite the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{gao2024automateddiscoverybranchingrules,\n      title={Automated Discovery of Branching Rules with Optimal Complexity for the Maximum Independent Set Problem}, \n      author={Xuan-Zhao Gao and Yi-Jia Wang and Pan Zhang and Jin-Guo Liu},\n      year={2024},\n      eprint={2412.07685},\n      archivePrefix={arXiv},\n      primaryClass={math.OC},\n      url={https://arxiv.org/abs/2412.07685}, \n}","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = OptimalBranching\nDocTestSetup = quote\n    using OptimalBranching\n    using OptimalBranchingCore\n    using Graphs\nend","category":"page"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This section will provide a brief introduction about how to use the OptimalBranching.jl package.","category":"page"},{"location":"quick-start/#The-maximum-independent-set-problem","page":"Quick Start","title":"The maximum independent set problem","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We provided two simple interfaces to solve the maximum independent set problem and count the branches used in calculation.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using OptimalBranching, Graphs\ng = smallgraph(:tutte)\nmis_size(g) # this gives the size of the maximum independent set\nmis_branch_count(g) # this gives the size of the maximum independent set and the number of branches used in calculation","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can also select different strategies to solve the problem, which inclues ","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"AbstractTableSolver to solve the BranchingTable, \nAbstractSelector to select the branching variable, \nAbstractMeasure to measure the size of the problem, \nAbstractSetCoverSolver to solve the set cover problem, and \nAbstractReducer to reduce the problem.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Here is an example:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using OptimalBranchingCore, OptimalBranching, Graphs\nbranching_strategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundarySelector(2), measure=D3Measure(), set_cover_solver = IPSolver())\nmis_size(g, bs = branching_strategy, reducer = MISReducer())","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can also use the branch_and_reduce function to solve the problem, which is more flexible.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using OptimalBranchingCore, OptimalBranching, Graphs\nbranching_strategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundarySelector(2), measure=D3Measure(), set_cover_solver = IPSolver())\nbranch_and_reduce(MISProblem(g), branching_strategy, MISReducer(), MaxSizeBranchCount)","category":"page"}]
}
