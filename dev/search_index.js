var documenterSearchIndex = {"docs":
[{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"CurrentModule = OptimalBranchingCore\nDocTestSetup = quote\n    using OptimalBranching\n    using OptimalBranchingCore\n    using BitBasis\nend","category":"page"},{"location":"man/core/#core","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"","category":"section"},{"location":"man/core/#Literal,-Clause-and-DNF","page":"OptimalBranchingCore","title":"Literal, Clause and DNF","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Literals, clauses and disjunctive normal form (DNF) are basic concepts in boolean logic, where literals are boolean variables, clauses are boolean expressions, and DNF is a disjunction of one or more conjunctions of literals.","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Here is an example, given a truth table as follows:","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"a b c value\n0 0 0 1\n0 0 1 1\n0 1 0 0\n0 1 1 0\n1 0 0 0\n1 0 1 1\n1 1 0 0\n1 1 1 0","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"where a b c are boolean variables called literals. The true statements can be represented as a conjunction of literals, for example, ","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"neg a land neg b land neg c neg a land neg b land c a land neg b land c","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"and these clauses can be combined into a DNF:","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"(neg a land neg b) lor (a land neg b land c)","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"In OptimalBranchingCore, a clause is represented by the Clause type, and a DNF is represented by the DNF type, based on the BitBasis.jl package.","category":"page"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"using OptimalBranchingCore, BitBasis\nc1 = Clause(bit\"011\", bit\"000\")\nc2 = Clause(bit\"111\", bit\"101\")\ndnf = DNF(c1, c2)","category":"page"},{"location":"man/core/#The-branch-and-bound-algorithm","page":"OptimalBranchingCore","title":"The branch and bound algorithm","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"The branch and bound algorithm is a method to exactly solve the combinatorial optimization problems.","category":"page"},{"location":"man/core/#API","page":"OptimalBranchingCore","title":"API","text":"","category":"section"},{"location":"man/core/","page":"OptimalBranchingCore","title":"OptimalBranchingCore","text":"Modules = [OptimalBranchingCore]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/core/#OptimalBranchingCore.apply_branch","page":"OptimalBranchingCore","title":"OptimalBranchingCore.apply_branch","text":"apply_branch(problem::AbstractProblem, clause::Clause, vertices::Vector)::Tuple\n\nCreate a branch from the given clause applied to the specified vertices.\n\nArguments\n\nproblem: The problem instance.\nclause: The clause that containing the information about how to fix the values of the variables.\nvertices: A vector of vertices to be considered for the branch.\n\nReturns\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.branch_and_reduce-Tuple{AbstractProblem, BranchingStrategy, AbstractReducer, Any}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branch_and_reduce","text":"branch_and_reduce(problem::AbstractProblem, config::BranchingStrategy; reducer::AbstractReducer=NoReducer(), result_type=Int, show_progress=false)\n\nBranch the given problem using the specified solver configuration.\n\nArguments\n\nproblem: The problem instance to solve.\nconfig: The configuration for the solver, which is a BranchingStrategy instance.\n\nKeyword Arguments\n\nreducer::AbstractReducer=NoReducer(): The reducer to reduce the problem size.\nresult_type::Type{TR}: The type of the result that the solver will produce.\n\nReturns\n\nThe resulting value, which may have different type depending on the result_type.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.branching_table","page":"OptimalBranchingCore","title":"OptimalBranchingCore.branching_table","text":"branching_table(problem::AbstractProblem, table_solver::AbstractTableSolver, variables::Vector{Int})\n\nObtains the branching table for a given problem using a specified table solver.\n\nArguments\n\nproblem: The problem instance.\ntable_solver: The table solver, which is a subtype of AbstractTableSolver.\nvariables: A vector of indices of the variables to be considered for the branching table.\n\nReturns\n\nA branching table, which is a BranchingTable object.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.candidate_clauses-Union{Tuple{BranchingTable{INT}}, Tuple{INT}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.candidate_clauses","text":"candidate_clauses(tbl::BranchingTable{INT}) where {INT}\n\nGenerates candidate clauses from a branching table.\n\nArguments\n\ntbl::BranchingTable{INT}: The branching table containing bit strings.\n\nReturns\n\nVector{Clause{INT}}: A vector of Clause objects generated from the branching table.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.complexity_bv-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.complexity_bv","text":"complexity_bv(branching_vector::Vector)::Float64\n\nCalculates the complexity that associated with the provided branching vector by solving the equation:\n\nγ^0 = sum_δρ in textbranching_vector γ^-δρ\n\nArguments\n\nbranching_vector: a vector of problem size reductions in the branches.\n\nReturns\n\nFloat64: The computed γ value.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{BranchingTable, DNF}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(t::BranchingTable, dnf::DNF)\n\nCheck if the branching table t is covered by the logic expression dnf. Returns true if there exists at least one bitstring in each group of t that satisfies dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.covered_by-Tuple{Integer, Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.covered_by","text":"covered_by(a::Integer, clause_or_dnf)\n\nCheck if a is covered by the logic expression clause_or_dnf.\n\nArguments\n\na: A bit string.\nclause_or_dnf: Logic expression, which can be a Clause object or a DNF object.\n\nReturns\n\ntrue if a satisfies clause_or_dnf, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_false_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_false_literal","text":"is_false_literal(c::Clause)\n\nCheck if the clause is a false literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.is_true_literal-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.is_true_literal","text":"is_true_literal(c::Clause)\n\nCheck if the clause is a true literal.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.literals-Tuple{Clause}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.literals","text":"literals(c::Clause)\n\nReturn all literals in the clause.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.measure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.measure","text":"measure(problem::AbstractProblem, measure::AbstractMeasure)::Number\n\nCalculate the size of the problem, reducing which serves as the guiding principle for the branching strategy.\n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\n\nReturns\n\nA real number representing the problem size.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.minimize_γ-Union{Tuple{INT}, Tuple{BranchingTable, Array{Clause{INT}, 1}, Vector, AbstractSetCoverSolver}} where INT","page":"OptimalBranchingCore","title":"OptimalBranchingCore.minimize_γ","text":"minimize_γ(table::BranchingTable, candidates::Vector{Clause}, Δρ::Vector, solver)\n\nFinds the optimal cover based on the provided vector of problem size reduction. This function implements a cover selection algorithm using an iterative process. It utilizes an integer programming solver to optimize the selection of sub-covers based on their complexity.\n\nArguments\n\ntable::BranchingTable: A branching table containing clauses that need to be covered, a table entry is covered by a clause if one of its bit strings satisfies the clause. Please refer to covered_by for more details.\ncandidates::Vector{Clause}: A vector of candidate clauses to form the branching rule (in the form of DNF).\nΔρ::Vector: A vector of problem size reduction for each candidate clause.\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\n\nReturns\n\nA tuple of two elements: (indices of selected subsets, γ)\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.optimal_branching_rule-Tuple{BranchingTable, Vector, AbstractProblem, AbstractMeasure, AbstractSetCoverSolver}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.optimal_branching_rule","text":"optimal_branching_rule(table::BranchingTable, variables::Vector, problem::AbstractProblem, measure::AbstractMeasure, solver::AbstractSetCoverSolver)::OptimalBranchingResult\n\nGenerate an optimal branching rule from a given branching table.\n\nArguments\n\ntable: A BranchingTable instance containing candidate clauses.\nvariables: A vector of variables to perform the branching.\nproblem: The problem instance being solved.\nmeasure: The measure used for evaluating the problem size reduction in the branches.\nsolver: The solver used for the weighted minimum set cover problem, which can be either LPSolver or IPSolver.\n\nReturns\n\nA OptimalBranchingResult object representing the optimal branching rule.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.reduce_problem-Union{Tuple{T}, Tuple{Type{T}, AbstractProblem, NoReducer}} where T","page":"OptimalBranchingCore","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, problem::AbstractProblem, reducer::AbstractReducer) where R\n\nReduces the problem size directly, e.g. by graph rewriting. It is a crucial step in the reduce and branch strategy.\n\nArguments\n\nR: The element type used for computing the size of solution. The should have an additive commutative monoid structure.\nproblem: The problem instance.\nreducer: The reducer.\n\nReturns\n\nA tuple of two values:\n\nAbstractProblem: A new instance of AbstractProblem with reduced size.\nNumber: The local gain of the reduction, which will be added to the global gain.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.select_variables","page":"OptimalBranchingCore","title":"OptimalBranchingCore.select_variables","text":"select_variables(problem::AbstractProblem, measure::AbstractMeasure, selector::AbstractSelector)::Vector{Int}\n\nSelects a branching strategy for a AbstractProblem instance. \n\nArguments\n\nproblem: The problem instance.\nmeasure: The measure of the problem size.\nselector: The variables selection strategy, which is a subtype of AbstractSelector.\n\nReturns\n\nA vector of indices of the selected variables.\n\n\n\n\n\n","category":"function"},{"location":"man/core/#OptimalBranchingCore.weighted_minimum_set_cover-Tuple{LPSolver, AbstractVector, Vector{Vector{Int64}}, Int64}","page":"OptimalBranchingCore","title":"OptimalBranchingCore.weighted_minimum_set_cover","text":"weighted_minimum_set_cover(solver, weights::AbstractVector, subsets::Vector{Vector{Int}}, num_items::Int)\n\nSolves the weighted minimum set cover problem.\n\nArguments\n\nsolver: The solver to be used. It can be an instance of LPSolver or IPSolver.\nweights::AbstractVector: The weights of the subsets.\nsubsets::Vector{Vector{Int}}: A vector of subsets.\nnum_items::Int: The number of elements to cover.\n\nReturns\n\nA vector of indices of selected subsets.\n\n\n\n\n\n","category":"method"},{"location":"man/core/#OptimalBranchingCore.AbstractMeasure","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractMeasure","text":"AbstractMeasure\n\nThe base type for the measure of the problem size in terms of computational hardness. Some widely used measures include the number of variables, the vertices with connectivity of at least 3, etc.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractProblem","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractProblem","text":"AbstractProblem\n\nThe problem type that can be used in the optimal branching framework.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractReducer","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractReducer","text":"AbstractReducer\n\nAn abstract type representing a reducer in the context of branching problems.  This serves as a base type for all specific reducer implementations.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSelector","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSelector","text":"AbstractSelector\n\nAn abstract type for the strategy of selecting a subset of variables to be branched.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractSetCoverSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractSetCoverSolver","text":"AbstractSetCoverSolver\n\nAn abstract type for the strategy of solving the set covering problem.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.AbstractTableSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.AbstractTableSolver","text":"AbstractTableSolver\n\nAn abstract type for the strategy of obtaining the branching table.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingStrategy","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingStrategy","text":"BranchingStrategy\nBranchingStrategy(; kwargs...)\n\nA struct representing the configuration for a solver, including the reducer and branching strategy.\n\nFields\n\ntable_solver::AbstractTableSolver: The solver to resolve the relevant bit strings and generate a branching table.\nset_cover_solver::AbstractSetCoverSolver = IPSolver(): The solver to solve the set covering problem.\nselector::AbstractSelector: The selector to select the next branching variable or decision.\nm::AbstractMeasure: The measure to evaluate the performance of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.BranchingTable","page":"OptimalBranchingCore","title":"OptimalBranchingCore.BranchingTable","text":"BranchingTable{INT <: Integer}\n\nA list of groupped bitstrings, which is used for designing the branching rule. A valid branching rule, which is represented by a logic expression in Disjunctive Normal Form (DNF), should cover at least one bitstring from each group, where by cover, we mean there exists at least one bitstring in the group that satisfies the logic expression. Please check covered_by for more details.\n\nFields\n\nbit_length::Int: The length of the bit string.\ntable::Vector{Vector{INT}}: The list of groupped bitstrings used for branching, where each group is a vector of bitstrings. The bitstrings uses INT type to store the bitstring.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.CandidateClause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.CandidateClause","text":"CandidateClause{INT <: Integer}\n\nA candidate clause is a clause containing the formation related to how it can cover the items in the branching table.\n\nFields\n\ncovered_items::Set{Int}: The items in the branching table that are covered by the clause.\nclause::Clause{INT}: The clause itself.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.Clause","page":"OptimalBranchingCore","title":"OptimalBranchingCore.Clause","text":"Clause{INT <: Integer}\n\nA Clause is conjunction of literals, which is specified by a pair of bit strings. The type parameter INT is the integer type for storing the bit strings.\n\nFields\n\nmask: A bit string that indicates the variables involved in the clause.\nval: A bit string that indicates the positive literals in the clause.\n\nExamples\n\nTo check if a bit string satisfies a clause, use OptimalBranchingCore.covered_by.\n\njulia> using OptimalBranchingCore\n\njulia> clause = Clause(0b1110, 0b1010)\nClause{UInt8}: #2 ∧ ¬#3 ∧ #4\n\njulia> OptimalBranchingCore.covered_by(0b1110, clause)\nfalse\n\njulia> OptimalBranchingCore.covered_by(0b1010, clause)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.DNF","page":"OptimalBranchingCore","title":"OptimalBranchingCore.DNF","text":"DNF{INT}\n\nA data structure representing a logic expression in Disjunctive Normal Form (DNF), which is a disjunction of one or more conjunctions of literals. In OptimalBranchingCore, a DNF is used to represent the branching rule.\n\nFields\n\nclauses::Vector{Clause{INT}}: A vector of Clause objects.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.IPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.IPSolver","text":"IPSolver <: AbstractSetCoverSolver\nIPSolver(; optimizer = HiGHS.Optimizer, max_itr::Int = 20, γ0::Float64 = 2.0, verbose::Bool = false)\n\nAn integer programming solver for set covering problems.\n\nFields\n\noptimizer: The optimizer to be used.\nmax_itr::Int: The maximum number of iterations to be performed.\nγ0::Float64: The initial γ value.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.LPSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.LPSolver","text":"LPSolver <: AbstractSetCoverSolver\nLPSolver(; optimizer = HiGHS.Optimizer, max_itr::Int = 20, γ0::Float64 = 2.0, verbose::Bool = false)\n\nA linear programming solver for set covering problems.\n\nFields\n\noptimizer: The optimizer to be used.\nmax_itr::Int: The maximum number of iterations to be performed.\nγ0::Float64: The initial γ value.\nverbose::Bool: Whether to print the solver's output.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSize","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSize","text":"MaxSize\n\nA struct representing the maximum size of a result. (actually a tropical int)\n\nFields\n\nsize::Int: The maximum size value.\n\nConstructors\n\nMaxSize(size::Int): Creates a MaxSize instance with the specified size.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MaxSizeBranchCount","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MaxSizeBranchCount","text":"struct MaxSizeBranchCount\n\nReture both the max size of the results and number of branches.\n\nFields\n\nsize::Int: The max size of the results.\ncount::Int: The number of branches of that size.\n\nConstructors\n\nMaxSizeBranchCount(size::Int): Creates a MaxSizeBranchCount with the given size and initializes the count to 1.\nMaxSizeBranchCount(size::Int, count::Int): Creates a MaxSizeBranchCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.MockTableSolver","page":"OptimalBranchingCore","title":"OptimalBranchingCore.MockTableSolver","text":"struct MockTableSolver <: AbstractTableSolver\n\nThe MockTableSolver randomly generates a branching table with a given number of rows. Each row must have at least one variable to be covered by the branching rule.\n\nFields\n\nn::Int: The number of rows in the branching table.\np::Float64 = 0.0: The probability of generating more than one variables in a row, following the Poisson distribution.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.NumOfVariables","page":"OptimalBranchingCore","title":"OptimalBranchingCore.NumOfVariables","text":"NumOfVariables\n\nA struct representing a measure that counts the number of variables in a problem.  Each variable is counted as 1.\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.OptimalBranchingResult","page":"OptimalBranchingCore","title":"OptimalBranchingCore.OptimalBranchingResult","text":"OptimalBranchingResult{INT <: Integer}\n\nThe result type for the optimal branching rule.\n\nFields\n\noptimal_rule::DNF{INT}: The optimal branching rule.\nbranching_vector::Vector{T<:Real}: The branching vector that records the size reduction in each subproblem.\nγ::Float64: The optimal γ value (the complexity of the branching rule).\n\n\n\n\n\n","category":"type"},{"location":"man/core/#OptimalBranchingCore.RandomSelector","page":"OptimalBranchingCore","title":"OptimalBranchingCore.RandomSelector","text":"struct RandomSelector <: AbstractSelector\n\nThe RandomSelector struct represents a strategy for selecting a subset of variables randomly.\n\nFields\n\nn::Int: The number of variables to select.\n\n\n\n\n\n","category":"type"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/#The-maximum-independent-set-problem","page":"Benchmarks","title":"The maximum independent set problem","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"We benchmarked the branch-and-reduce algorithm based on the optimal branching algorithm on the maximum independent set problem against various state-of-the-art solvers, where we compared the number of branches needed to solve the problem.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Our mehtod is denoted as textttob and textttob+xiao, and the previous method include textttxiao2013 and textttakiba2015. We compared the performance of these methods in 3-regular graphs, Erdős–Rényi random graphs, grid graphs and King's sub-graphs, for each size we generated 1000 random graphs.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The average number of branches needed to solve the problem is shown in the following figure:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: )","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The maximum number of branches needed to solve the problem among 1000 graphs is shown in the following figure:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"(Image: )","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These numerical results show that our method is competitive with the previous methods with less human-designed rules.","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"EditURL = \"../../../examples/rule_discovery.jl\"","category":"page"},{"location":"generated/rule_discovery/#Automatic-rule-discovery","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"using OptimalBranching.OptimalBranchingMIS.Graphs, OptimalBranching\nusing OptimalBranching.OptimalBranchingCore, OptimalBranching.OptimalBranchingCore.BitBasis","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"This function generates the tree-like N3 neighborhood of g0.","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"function tree_like_N3_neighborhood(g0::SimpleGraph)\n    g = copy(g0)\n    for layer in 1:3\n        for v in vertices(g)\n            for _ = 1:(3-degree(g, v))\n                add_vertex!(g)\n                add_edge!(g, v, nv(g))\n            end\n        end\n    end\n    return g\nend\n\nfunction solve_opt_rule(branching_region, graph, vs)\n    # Use default solver and measure\n    m = D3Measure()\n    table_solver = TensorNetworkSolver(; prune_by_env=true)\n    set_cover_solver = IPSolver()\n\n    # Pruning irrelevant entries\n    ovs = OptimalBranchingMIS.open_vertices(graph, vs)\n    subg, vmap = induced_subgraph(graph, vs)\n    @info \"solving the branching table...\"\n    tbl = OptimalBranchingMIS.reduced_alpha_configs(table_solver, subg, Int[findfirst(==(v), vs) for v in ovs])\n    @info \"the length of the truth_table after pruning irrelevant entries: $(length(tbl.table))\"\n\n    @info \"generating candidate clauses...\"\n    candidate_clauses = OptimalBranchingMIS.OptimalBranchingCore.candidate_clauses(tbl)\n    @info \"the length of the candidate clauses: $(length(candidate_clauses))\"\n\n    @info \"generating the optimal branching rule via set cover...\"\n    problem = MISProblem(graph)\n    size_reductions = [measure(problem, m) - measure(first(OptimalBranchingCore.apply_branch(problem, candidate, vs)), m) for candidate in candidate_clauses]\n    result = OptimalBranchingMIS.OptimalBranchingCore.minimize_γ(tbl, candidate_clauses, size_reductions, set_cover_solver)\n    @info \"the minimized gamma: $(result.γ)\"\n\n    @info \"the optimal branching rule on R:\"\n    viz_dnf(result.optimal_rule, vs)\nend\n\nfunction viz_dnf(dnf::DNF{INT}, variables::Vector{T}) where {T, INT}\n    for c in dnf.clauses\n        println(join([iszero(readbit(c.val, i)) ? \"¬$(variables[i])\" : \"$(variables[i])\" for i = 1:bsizeof(INT) if readbit(c.mask, i) == 1], \" ∧ \"))\n    end\nend","category":"page"},{"location":"generated/rule_discovery/#Domination-rule","page":"Automatic rule discovery","title":"Domination rule","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5]\nedges = [(1, 2), (2, 3), (1, 3), (2, 4), (3, 4), (2, 5), (4, 5)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))\n\ngraph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/#PH2-rule","page":"Automatic rule discovery","title":"PH2 rule","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5,6,7,8]\nedges = [(1, 2), (1, 5), (2, 3), (2, 6), (3, 4), (4, 5), (5, 8), (6, 7), (7, 8)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Generate the tree-like N3 neighborhood of R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"graph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/#Bottleneck-case","page":"Automatic rule discovery","title":"Bottleneck case","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Define the branching region R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"vs = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]\nedges = [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10), (5, 11), (5, 12), (6, 13), (6, 14), (7, 15), (7, 16), (8, 17), (8, 18), (9, 19), (9, 20), (10, 21), (10, 22), (11, 14), (12, 13), (15, 18), (16, 17), (19, 22), (20, 21)]\nbranching_region = SimpleGraph(Graphs.SimpleEdge.(edges))","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"Generate the tree-like N3 neighborhood of R","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"graph = tree_like_N3_neighborhood(branching_region)\n\nsolve_opt_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/#Generating-rules-for-large-scale-problems","page":"Automatic rule discovery","title":"Generating rules for large scale problems","text":"","category":"section"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"For large scale problems, we can use the greedy merge rule to generate rules, which avoids generating all candidate clauses.","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"function solve_greedy_rule(branching_region, graph, vs)\n    # Use default solver and measure\n    m = D3Measure()\n    table_solver = TensorNetworkSolver(; prune_by_env=true)\n\n    # Pruning irrelevant entries\n    ovs = OptimalBranchingMIS.open_vertices(graph, vs)\n    subg, vmap = induced_subgraph(graph, vs)\n    @info \"solving the branching table...\"\n    tbl = OptimalBranchingMIS.reduced_alpha_configs(table_solver, subg, Int[findfirst(==(v), vs) for v in ovs])\n    @info \"the length of the truth_table after pruning irrelevant entries: $(length(tbl.table))\"\n\n    @info \"generating the optimal branching rule via greedy merge...\"\n    candidates = OptimalBranchingCore.bit_clauses(tbl)\n    result = OptimalBranchingMIS.OptimalBranchingCore.greedymerge(candidates, MISProblem(graph), vs, m)\n    return result\n    @info \"the greedily minimized gamma: $(result.γ)\"\n\n    @info \"the branching rule on R:\"\n    viz_dnf(result.optimal_rule, vs)\nend\n\nresult = solve_greedy_rule(branching_region, graph, vs)","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"","category":"page"},{"location":"generated/rule_discovery/","page":"Automatic rule discovery","title":"Automatic rule discovery","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performance_tips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performance_tips/#Using-a-better-integer-programming-solver","page":"Performance Tips","title":"Using a better integer programming solver","text":"","category":"section"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"Solving the optimal branching rule involves solving a weighted minimum set cover problem, which is converted to an integer programming problem and solved by IPSolver. For branching regions with a large number of variables, the performance of the solver may be the bottleneck of the whole algorithm. We set the default integer programming solver to HiGHS, which can be ~10x slower comparing with the state-of-the-art commercial solvers such as Gurobi and CPLEX.","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"To get a better understanding of the performance of different integer programming solvers, we recommend reading this issue.","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"In the following example, we switch the integer programming solver to SCIP (at version 0.11) to solve the problem.","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"using OptimalBranching, Graphs\nusing OptimalBranching.OptimalBranchingCore\nusing SCIP\ng = smallgraph(:tutte)\nbranching_strategy = BranchingStrategy(\n    table_solver = TensorNetworkSolver(),\n    selector = MinBoundarySelector(2),\n    measure = D3Measure(),\n    set_cover_solver = IPSolver(optimizer = SCIP.Optimizer)\n)\nmis_size(g, bs = branching_strategy, reducer = MISReducer())","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"If approximately optimal branching rules are acceptable, one can also use the linear relaxation of the set cover problem to solve the problem.","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"branching_strategy_lp = BranchingStrategy(\n    table_solver = TensorNetworkSolver(),\n    selector = MinBoundarySelector(2),\n    measure = D3Measure(),\n    set_cover_solver = LPSolver()\n)\nmis_size(g, bs = branching_strategy_lp, reducer = MISReducer())","category":"page"},{"location":"performance_tips/","page":"Performance Tips","title":"Performance Tips","text":"The default backend is also HiGHS. While the result is consistent, the rule searching is usually faster.","category":"page"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"CurrentModule = OptimalBranchingMIS","category":"page"},{"location":"man/mis/#OptimalBranchingMIS","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"","category":"section"},{"location":"man/mis/#The-maximum-independent-set-problem","page":"OptimalBranchingMIS","title":"The maximum independent set problem","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"The maximum independent set problem is a classical combinatorial optimization problem, which is to find the largest subset of vertices in a graph such that no two vertices in the subset are adjacent.","category":"page"},{"location":"man/mis/#Designing-a-branch-and-reduce-algorithm-using-the-optimal-branching-algorithm","page":"OptimalBranchingMIS","title":"Designing a branch-and-reduce algorithm using the optimal branching algorithm","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"To solve the MIS problem, we use the framework provided by the OptimalBranchingCore package to design a branch-and-reduce algorithm.","category":"page"},{"location":"man/mis/#API","page":"OptimalBranchingMIS","title":"API","text":"","category":"section"},{"location":"man/mis/","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS","text":"Modules = [OptimalBranchingMIS]\nOrder = [:macro, :function, :type, :module]","category":"page"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, D3Measure}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::D3Measure)\n\nCalculates the D3 measure for the given MISProblem, which is defined as the sum of  the maximum degree of each vertex minus 2, for all vertices in the graph.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The computed D3 measure value.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.measure-Tuple{MISProblem, NumOfVertices}","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.measure","text":"measure(p::MISProblem, ::NumOfVertices)\n\nCalculates the number of vertices in the given MISProblem.\n\nArguments\n\np::MISProblem: The problem instance containing the graph.\n\nReturns\n\nInt: The number of vertices in the graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingCore.reduce_problem-Union{Tuple{R}, Tuple{Type{R}, MISProblem, MISReducer}} where R","page":"OptimalBranchingMIS","title":"OptimalBranchingCore.reduce_problem","text":"reduce_problem(::Type{R}, p::MISProblem, ::MISReducer) where R\n\nReduces the given MISProblem by removing vertices based on their degrees and returns a new MISProblem instance along with the count of removed vertices.\n\nArguments\n\np::MISProblem: The problem instance containing the graph to be reduced.\n::MISReducer: An instance of the MISReducer struct.\n::Type{R}: The type of the result expected.\n\nReturns\n\nA tuple containing:\nA new MISProblem instance with specified vertices removed.\nAn integer representing the count of removed vertices.\n\nDescription\n\nThe function checks the number of vertices in the graph:\n\nIf there are no vertices, it returns an empty instance and a count of 0.\nIf there is one vertex, it returns an empty instance and a count of 1.\nIf there are two vertices, it returns an empty instance and a count based on the presence of an edge between them.\nFor graphs with more than two vertices, it calculates the degrees of the vertices and identifies the vertex with the minimum degree to determine which vertices to remove.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.closed_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.closed_neighbors","text":"closed_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a set of vertices that includes the input vertices as well as their open neighbors.\n\nArguments\n\ng::SimpleGraph: The input graph.\nvertices::Vector{Int}: The vertices for which closed neighbors are to be computed.\n\nReturns\n\nA set of vertices that includes the input vertices as well as their open neighbors.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis1-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis1","text":"counting_mis1(g::SimpleGraph)\n\nCalculates the maximum independent set (MIS) for a given SimpleGraph by first converting it into an EliminateGraph and then applying the counting_mis1 function.\n\nArguments\n\ng::SimpleGraph: The input graph for which the maximum independent set is to be calculated.\n\nReturns\n\nMISCount: The size of the maximum independent set for the provided graph and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_mis2-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_mis2","text":"counting_mis2(g::SimpleGraph)\n\nCalculates the size of the maximum independent set and the count of branches for a given SimpleGraph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.counting_xiao2013-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.counting_xiao2013","text":"counting_xiao2013(g::SimpleGraph)\n\nThis function counts the maximum independent set (MIS) in a given simple graph using the Xiao 2013 algorithm.\n\nArguments\n\ng::SimpleGraph: A simple graph for which the maximum independent set is to be counted.\n\nReturns\n\nCountingMIS: An object representing the size of the maximum independent set and the count of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_branch_count-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_branch_count","text":"mis_branch_count(g::AbstractGraph; branching_strategy::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundaryHighDegreeSelector(2, 6, 0), measure=D3Measure()), reducer=MISReducer(), show_progress::Bool = false)\n\nCalculate the size and the number of branches of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size and the number of branches are to be calculated.\n\nKeyword Arguments\n\nbranching_strategy::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundaryHighDegreeSelector(2, 6, 0), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\nshow_progress::Bool: (optional) Whether to show the progress of the branching and reduction process. Defaults to false.\n\nReturns\n\nA tuple (size, count) where size is the size of the Maximum Independent Set and count is the number of branches.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.mis_size-Tuple{Graphs.AbstractGraph}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.mis_size","text":"mis_size(g::AbstractGraph; branching_strategy::BranchingStrategy = BranchingStrategy(table_solver = TensorNetworkSolver(), selector = MinBoundaryHighDegreeSelector(2, 6, 0), measure=D3Measure()), reducer::AbstractReducer = MISReducer(), show_progress::Bool = false)\n\nCalculate the size of the Maximum Independent Set (MIS) for a given graph.\n\nArguments\n\ng::AbstractGraph: The graph for which the MIS size is to be calculated.\n\nKeyword Arguments\n\nbranching_strategy::BranchingStrategy: (optional) The branching strategy to be used. Defaults to a strategy using table_solver=TensorNetworkSolver, selector=MinBoundaryHighDegreeSelector(2, 6, 0), and measure=D3Measure.\nreducer::AbstractReducer: (optional) The reducer to be applied. Defaults to MISReducer.\nshow_progress::Bool: (optional) Whether to show the progress of the branching and reduction process. Defaults to false.\n\nReturns\n\nAn integer representing the size of the Maximum Independent Set for the given graph.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbor_cover-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbor_cover","text":"neighbor_cover(g::SimpleGraph, v::Int, k::Int)\n\nCompute the neighbor cover of a vertex in a graph.\n\nArguments\n\ng::SimpleGraph: The input graph.\nv::Int: The vertex for which to compute the neighbor cover.\nk::Int: The number of iterations to perform.\n\nReturns\n\nvertices: An array containing the vertices in the neighbor cover.\nopenvertices: An array containing the open vertices in the neighbor cover.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.neighbors_2nd-Tuple{Graphs.SimpleGraphs.SimpleGraph, Int64}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.neighbors_2nd","text":"neighbors_2nd(g::SimpleGraph, v::Int)\n\nReturn the second-order neighbors of a vertex v in a simple graph g.\n\nArguments\n\ng::SimpleGraph: The simple graph.\nv::Int: The vertex.\n\nReturns\n\nArray{Int}: An array of second-order neighbors of v.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_neighbors-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_neighbors","text":"open_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a vector of vertices in the graph g, which are neighbors of the given vertices and not in the given vertices.\n\nArguments\n\ng::SimpleGraph: The graph in which to find the open neighbors.\nvertices::Vector{Int}: The vertices for which to find the open neighbors.\n\nReturns\n\nA vector of open neighbors of the given vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.open_vertices-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{Int64}}","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.open_vertices","text":"open_vertices(g::SimpleGraph, vertices::Vector{Int})\n\nRemove vertices from the given vector that are connected to all other vertices in the graph.\n\nArguments\n\ng::SimpleGraph: The graph object.\nvertices::Vector{Int}: The vector of vertices.\n\nReturns\n\nVector{Int}: The open vertices.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.removed_vertices-Union{Tuple{N}, Tuple{Vector{Int64}, Graphs.SimpleGraphs.SimpleGraph, Clause{N}}} where N","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.removed_vertices","text":"removed_vertices(vertices::Vector{Int}, g::SimpleGraph, clause::Clause{N}) where N\n\nGiven a list of vertices, a graph, and a clause, this function returns a list of removed vertices. \n\nThe vertices argument is a vector of integers representing the vertices to consider.  The g argument is a SimpleGraph object representing the graph. The clause argument is a Clause object representing a clause.\n\nThe function iterates over the vertices and checks if the corresponding bit in the clause.mask is 1.  If it is, the vertex is added to the list of removed vertices (rvs).  If the corresponding bit in the clause.val is also 1, the neighbors of the vertex are also added to rvs.\n\nThe function returns the list of removed vertices with duplicates removed.\n\n\n\n\n\n","category":"method"},{"location":"man/mis/#OptimalBranchingMIS.D3Measure","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.D3Measure","text":"D3Measure\n\nA struct representing a measure that calculates the sum of the maximum degree minus 2 for each vertex in the graph.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISCount","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISCount","text":"struct MISCount\n\nRepresents the count of Maximum Independent Sets (MIS).\n\nFields\n\nmis_size::Int: The size of the Maximum Independent Set.\nmis_count::Int: The number of Maximum Independent Sets of that size.\n\nConstructors\n\nMISCount(mis_size::Int): Creates a MISCount with the given size and initializes the count to 1.\nMISCount(mis_size::Int, mis_count::Int): Creates a MISCount with the specified size and count.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISProblem","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISProblem","text":"mutable struct MISProblem{INT <: Integer} <: AbstractProblem\n\nRepresents a Maximum Independent Set (MIS) problem.\n\nFields\n\ng::SimpleGraph: The graph associated with the MIS problem.\n\nMethods\n\ncopy(p::MISProblem): Creates a copy of the given MISProblem.\nBase.show(io::IO, p::MISProblem): Displays the number of vertices in the MISProblem.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MISReducer","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MISReducer","text":"MISReducer\n\nA struct representing a reducer for the Maximum Independent Set (MIS) problem.  This struct serves as a specific implementation of the AbstractReducer type.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundaryHighDegreeSelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundaryHighDegreeSelector","text":"struct MinBoundaryHighDegreeSelector <: AbstractVertexSelector\n\nThe MinBoundaryHighDegreeSelector struct represents a strategy:     - if exists a vertex with degree geq highdegreethreshold, then select it and its k-degree neighbors.     - otherwise, select a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nkb::Int: The number of layers of neighbors to consider when selecting the subgraph.\nhd::Int: The threshold of degree for a vertex to be selected.\nkd::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.MinBoundarySelector","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.MinBoundarySelector","text":"struct MinBoundarySelector <: AbstractVertexSelector\n\nThe MinBoundarySelector struct represents a strategy for selecting a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nk::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.NumOfVertices","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.NumOfVertices","text":"NumOfVertices\n\nA struct representing a measure that counts the number of vertices in a graph.  Each vertex is counted as 1.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"man/mis/#OptimalBranchingMIS.TensorNetworkSolver","page":"OptimalBranchingMIS","title":"OptimalBranchingMIS.TensorNetworkSolver","text":"TensorNetworkSolver\nTensorNetworkSolver(; prune_by_env::Bool = true)\n\nA struct representing a solver for tensor network problems.  This struct serves as a specific implementation of the AbstractTableSolver type.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OptimalBranching","category":"page"},{"location":"#OptimalBranching.jl","page":"Home","title":"OptimalBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to OptimalBranching. OptimalBranching.jl is a collection of tools for solving combinatorial optimization problems with branch-and-reduce method. It is written in Julia and features automatically generated branching rules with provable optimality (arXiv: 2412.07685). The rule generation is problem agnostic, and it can be easily extended to other problems. It contains two submodules:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OptimalBranchingCore.jl: the core algorithms, which convert the problem of searching the optimal branching rule into the problem of searching the optimal set cover.\nOptimalBranchingMIS.jl: the maximum independent set (MIS) problem solver based on the optimal branching algorithms.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p> OptimalBranching is a &nbsp;     <a href=\"https://julialang.org\">         <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">         Julia Language     </a>     &nbsp; package. To install OptimalBranching,     please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open     Julia's interactive session (known as REPL)</a> and press <kbd>]</kbd> key in the REPL to use the package mode, then type the following command </p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add OptimalBranchingCore  # for the core algorithms\n\npkg> add OptimalBranching      # for utilities based on the core algorithms","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have problem to install the package, please file us an issue.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Note: This part is working in progress, for more details, please refer to the paper.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/core.md\",\n    \"man/mis.md\",\n]\nDepth = 1","category":"page"},{"location":"#How-to-Contribute","page":"Home","title":"How to Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find any bug or have any suggestion, please open an issue. To develop the package, just download the source code by","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/OptimalBranching/OptimalBranching.jl\n$ cd OptimalBranching.jl\n$ make","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will add the submodules OptimalBranchingCore.jl and OptimalBranchingMIS.jl automatically, and the tests will be run automatically to ensure everything is fine.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this package useful in your research, please cite the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{Gao2024,\n    title={Automated Discovery of Branching Rules with Optimal Complexity for the Maximum Independent Set Problem}, \n    author={Xuan-Zhao Gao and Yi-Jia Wang and Pan Zhang and Jin-Guo Liu},\n    year={2024},\n    eprint={2412.07685},\n    archivePrefix={arXiv},\n    primaryClass={math.OC},\n    url={https://arxiv.org/abs/2412.07685}, \n}","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"CurrentModule = OptimalBranching\nDocTestSetup = quote\n    using OptimalBranching\n    using OptimalBranchingCore\n    using Graphs\nend","category":"page"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This section will provide a brief introduction about how to use the OptimalBranching.jl package.","category":"page"},{"location":"quick-start/#The-maximum-independent-set-problem","page":"Quick Start","title":"The maximum independent set problem","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We provided two simple interfaces to solve the maximum independent set problem and count the branches used in calculation.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using OptimalBranching, Graphs\ng = smallgraph(:tutte)\nmis_size(g) # the size of the maximum independent set (MIS)\nmis_branch_count(g) # MIS size and the number of branches used in calculation","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can also select different strategies to solve the problem, which inclues ","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"AbstractTableSolver to solve the BranchingTable, \nAbstractSelector to select the branching variable, \nAbstractMeasure to measure the size of the problem, \nAbstractSetCoverSolver to solve the set cover problem, and \nAbstractReducer to reduce the problem.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Here is an example:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"branching_strategy = BranchingStrategy(\n    table_solver = TensorNetworkSolver(), \n    selector = MinBoundarySelector(2), \n    measure = D3Measure(), \n    set_cover_solver = IPSolver()\n)\nmis_size(g, bs = branching_strategy, reducer = MISReducer())","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can also use the branch_and_reduce function to solve the problem, which is more flexible.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"branch_and_reduce(MISProblem(g), branching_strategy, MISReducer(), MaxSizeBranchCount)","category":"page"},{"location":"quick-start/#The-optimal-branching-rule","page":"Quick Start","title":"The optimal branching rule","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"We first specify a branching table, which is a table of bitstrings that the rule needs to cover. At least one bitstring in each row of the table is needed to be covered.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using OptimalBranchingCore\ntbl = BranchingTable(5, [\n        [[0, 0, 0, 0, 1], [0, 0, 0, 1, 0]],\n        [[0, 0, 1, 0, 1]],\n        [[0, 1, 0, 1, 0]],\n        [[1, 1, 1, 0, 0]]])","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Then, we generate the candidate clauses, which are the clauses forming the branching rule (a DNF formula).","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"candidates = OptimalBranchingCore.candidate_clauses(tbl)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For each candidate clause, we calculate the size reduction of the problem after applying the clause. Here, we use a simple measure: counting the number of variables eliminated by the clause.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Δρ = [length(literals(sc)) for sc in candidates]; println(Δρ)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Finally, we solve the set cover problem to find the optimal branching rule. The solver is set to be the IPSolver. For more options, please refer to the Performance Tips section.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"res_ip = OptimalBranchingCore.minimize_γ(tbl, candidates, Δρ, IPSolver())","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"The result is an instance of OptimalBranchingResult, which contains the selected clauses, the optimal branching rule, and the branching vector.","category":"page"}]
}
